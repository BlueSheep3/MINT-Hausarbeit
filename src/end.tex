\section{Fazit}

Die Optimierungen von Culling und Greedy Meshing
kombiniert ergeben etwa eine Verdopplung der
Performance und einer Halbierung der Anzahl
von Dreiecke in jedem Polygonnetz.
Wir können mit diesen Optimierungen
immer noch nicht-volle Voxels anzeigen,
und haben wir gesehen, wie mehrere Texturen
auf einem einzigen Dreieck angezeigt werden können.

\vspace{0.3cm}

Mögliche Optimierungen, die man noch implementieren
könnte, wären:
\begin{itemize}
	\item \href{https://de.wikipedia.org/wiki/Level_of_Detail}{Level Of Detail} \cite{lod}:
		Chunks, die weiter weg sind, könnten mit
		geringerer Genauigkeit erstellt werden,
		da man die Ungenauigkeiten von der Distanz
		nicht bemerken würde.
	\item \href{https://en.wikipedia.org/wiki/Hidden-surface_determination#Occlusion_culling}{Occlusion Culling} \cite{occlusion}:
		Gesamte Chunks sind oft nicht sichtbar.
		Zum Beispiel Höhlen sind oft nicht sichtbar,
		da sie unter der Erde sind. Diese Chunks
		könnten übersprungen werden.
	\item Culling und Greedy Meshing bei nicht-vollen Voxels:
		Meine Implementation wendet Culling und
		Greedy Meshing bei nicht-vollen Voxels
		nicht an, da diese komplizierter zu implementieren
		sind, weil sie zum Beispiel nur an bestimmten
		Seiten geculled werden können.
		In Situationen, wo es sehr viele nicht-volle
		Voxels gibt, könnte das aber ein großes Problem
		für Performance werden.
\end{itemize}
